#ifndef HERWIG_SINGLESAMPLER_H
#define HERWIG_SINGLESAMPLER_H

#include "ThePEG/MatrixElement/DiagramBase.h"
#include "Herwig/Sampling/BinSampler.h"
#include "Herwig/Sampling/CellGrids/SimpleCellGrid.h"
#include "DiagramSampler.h"

namespace Herwig {
    using namespace ThePEG;

    class DiagramSampler;

    /**
     * Sampler for a single diagram
     */
    class SingleSampler {
    public:
        SingleSampler();

        SingleSampler(const RCPtr<DiagramBase>& diagram, DiagramSampler* parent);

        virtual ~SingleSampler();

        /**
         * Set the coordinate of the diagram
         * */
        void diagramPosition(double d) { theDiagramPosition = d; }

        /**
         * Get the coordinate of the diagram
         * */
        double diagramPosition() const { return theDiagramPosition; }

    public:

        /**
         * Generate the next point; store the point in lastPoint() and its
         * weight using select(); if noMaxInfo is true, do not throw
         * NewMaximum or UpdateCrossSections exceptions.
         */
        double generate();

        /**
         * Adapt the sampler.
         * @param factor relative contribution of this sampler to the total integral
         */
        void adapt(double factor);

        /**
         * Evaluate the matrix element at a given point.
         * @param point a vector of size n-1 (the dimension controlling the diagram must be omitted)
         * @return the matrix element at that point
         */
        double evaluate(std::vector<double> point);

        /**
         * Similar to the explore step of the CellGridSampler.
         * @param progress current progress_display, if it exists
         * @param frac relative contribution of this sampler to the total integral
         * @return true iff no new structures where generated. The exploration of this node is then completed.
         */
        bool explore(progress_display* progress, double frac);

        /**
         * Performs the splits wanted at initialisation.
         */
        void split();

        /**
        * Finshes the explore step.
        */
        void finishExplore();

        /**
         * Loads this Sampler from the XML-Element.
         * @param elem the element representing this sampler
         */
        void fromXML(const XML::Element& elem);

        /**
         * Serializes this samplers grid to a XML-Element.
         * @return this sampler as XML
         */
        XML::Element toXML() const;

    public:

        /*
         * Gets the diagram.
         */
        RCPtr<DiagramBase> diagram() const { return theDiagram; }

        /*
         * Sets the diagram.
         */
        void diagram(const RCPtr<DiagramBase>& diagram) { theDiagram = diagram; }

        /**
         * Gets the parent sampler.
         * @return the parent sampler
         */
        DiagramSampler* parent() const {
            return theParent;
        }

        /**
         * Sets the parent sampler.
         * @param parent the new parent.
         */
        void parent(DiagramSampler* parent) {
            theParent = parent;
        }

        /**
         * Gets the id of the used diagram.
         * @return the id of the diagram.
         */
        int id() const {
            return theDiagram->id();
        }

        /**
         * Gets the current integral of this sampler.
         * @return the current integral.
         */
        double integral() const {
            return theIntegral;
        }

        /**
         * Gets the current (not normalised) selection probability of this sampler.
         * @return the selection probability
         */
        double probability() const {
            return theProbability;
        }

        /**
         * Sets the current selection probability.
         * @param prob the new selection probability
         */
        void probability(double prob) {
            theProbability = prob;
        }

        /**
         * Gets the number of points used to sample this diagram since the last reset.
         * @return the number of points generated by this sampler
         */
        unsigned pointCount() const {
            return thePointCount;
        }

        /**
         * Resets internal statistics.
         */
        void resetStats() {
            thePointCount = 0;
        }

        /**
         * Update the integral from the underlying CellGrid.
         */
        void updateIntegral();

    private:

        /**
         * The assignment operator is private and must never be called.
         * In fact, it should not even be implemented.
         */
        SingleSampler& operator=(const SingleSampler&) = delete;

    private:
        /**
         * Pointer to the current diagram
         */
        RCPtr<DiagramBase> theDiagram;

        /**
         * Pointer to the parent
         */
        DiagramSampler* theParent{};

        /**
         * The root node of the underlying grid
         */
        ExSample::SimpleCellGrid rootNode;

        /**
         * Points in current iteration
         */
        unsigned thePointCount = 0;
        /**
         * Integral of this sampler
         */
        double theIntegral = 0;

        /**
         * Selection probability
         */
        double theProbability = 0;

        /**
         * Coordinate of the diagram
         */
        double theDiagramPosition = 0;

        /**
         * flag if exploration has completed
         */
        bool exploreDone = false;
    };
}


#endif //HERWIG_SINGLESAMPLER_H
